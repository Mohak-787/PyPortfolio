import tkinter as tk
from tkinter import messagebox
from tkinter import ttk

# ----------------------------------------------------------------------
# GLOBAL DATA STRUCTURE (Ex 3 & 4: All functions must use this)
# Stored as a List of Lists: [[Name, Phone, Email, Address], [...]]
# ----------------------------------------------------------------------
CONTACTS_LIST = [
]

# ======================================================================
# CORE LOGIC FUNCTIONS (Students will COMPLETE these)
# ======================================================================

# Note: These are simplified stubs. Students must complete the loop/conditional logic


def add_contact(name, phone, email, address):
    """
    Adds a new contact to the global list.
    Requires: Strings, Lists, Functions.
    """
    if name and phone.isdigit():
        new_contact = [name, phone, email, address]
        CONTACTS_LIST.append(new_contact)

        with open("contacts.txt", "a") as file:
            file.write(",".join(new_contact) + "\n")
        
        return f"Successfully Added {name} in contact."
    elif not phone.isdigit():
        return "Try again! Phone must be digits only."
    else:
        return "Try again! Name and Phone fields must be filled."


def display_all_contacts(display_output_widget):
    """
    Clears the widget and displays all contacts using a loop.
    Requires: Loops, Lists, Functions.
    """
    display_output_widget.delete('1.0', tk.END)
    display_output_widget.insert(tk.END, "--- ALL CONTACTS ---\n")
    
    # STUDENT TASK: Implement the loop and formatting heres
    with open("contacts.txt", "a"):
        pass

    CONTACTS_LIST.clear()
    with open("contacts.txt", "r") as file:
        for line in file:
            line = line.strip()
            if line:
                contact = line.split(",")
                while len(contact) < 4:
                    contact.append("")
                CONTACTS_LIST.append(contact[:4])

    if not CONTACTS_LIST:
        display_output_widget.delete('1.0', tk.END)
        display_output_widget.insert(tk.END, "--- ALL CONTACTS ---\n", 'header') 
        display_output_widget.insert(tk.END, "No contacts found.\n")
        return "No contacts to display."

    # --- FORMATTING LOGIC (Generated by AI) ---
    
    # Clear the initial unstyled header (line 37) to insert the full, styled table view
    display_output_widget.delete('1.0', tk.END) 
    
    # Define column widths and header format for alignment
    W_NAME, W_PHONE, W_EMAIL = 25, 15, 30 
    header_format = f"{{:<{W_NAME}}} {{:<{W_PHONE}}} {{:<{W_EMAIL}}} {{}}\n"

    # Display Headers with style tags
    display_output_widget.insert(tk.END, "--- ALL CONTACTS ---\n", 'header')
    display_output_widget.insert(tk.END, header_format.format("NAME", "PHONE", "EMAIL", "ADDRESS"), 'column_header')
    display_output_widget.insert(tk.END, "-" * (W_NAME + W_PHONE + W_EMAIL + 10) + "\n")
    
    # Display Contacts with formatting (This replaces the simple ' '.join() loop)
    for contact in CONTACTS_LIST:
        output_string = header_format.format(contact[0], contact[1], contact[2], contact[3]) 
        display_output_widget.insert(tk.END, output_string)
    
    display_output_widget.insert(tk.END, f"\nTotal Contacts: {len(CONTACTS_LIST)}")
    return "Display complete."

def search_contact(search_name):
    """
    Uses a loop and conditional to find contacts 
    by a partial/case-insensitive name match. 
    """
    # Student implementation goes here
    found_contacts = []
    for contact in CONTACTS_LIST:
        if search_name.lower() in contact[0].lower():
            found_contacts.append(contact)

    if not found_contacts:
        return f"Unable to find {search_name} in contacts! Try Again."

    # --- FORMATTING LOGIC (Generated by AI) ---

    W_NAME, W_PHONE, W_EMAIL = 25, 15, 30
    header_format = f"{{:<{W_NAME}}} {{:<{W_PHONE}}} {{:<{W_EMAIL}}} {{}}\n"
    separator = "-" * (W_NAME + W_PHONE + W_EMAIL + 10) + "\n"

    # Structured output for handler to apply tags
    result_lines = f"Contacts found for {search_name}:\n"
    result_lines += header_format.format("NAME", "PHONE", "EMAIL", "ADDRESS")
    result_lines += separator
    
    for contact in found_contacts:
        result_lines += header_format.format(contact[0], contact[1], contact[2], contact[3])
        
    return result_lines


def delete_contact(target_name):
    """
    Finds a contact by name and removes it from the list. 
    """
    # Student implementation goes here
    for i, contact in enumerate(CONTACTS_LIST):
        if contact[0].lower() == target_name.lower():
            del CONTACTS_LIST[i]

            with open("contacts.txt", "w") as file:
                for c in CONTACTS_LIST:
                    file.write(",".join(c) + "\n")

            return f"{target_name} from contact was deleted successfully!"

    return f"Unable to find {target_name} in contacts! Try Again."


def update_contact(old_name, new_name, new_phone, new_email, new_address):
    """
    Finds a contact by old_name and replaces its details. 
    """
    # Student implementation goes here
    update_value = [new_name, new_phone, new_email, new_address]
    for i, contact in enumerate(CONTACTS_LIST):
        if contact[0].lower() == old_name.lower():
            for index, details in enumerate(update_value):
                if details:
                    CONTACTS_LIST[i][index] = details
            
            with open("contacts.txt", "w") as file:
                for c in CONTACTS_LIST:
                    file.write(",".join(c) + "\n")
            
            return f"Contact was successfully updated!"

    return f"Unable to find {old_name} in contact! Try Again"

# =====================================================================================
# TKINTER HANDLER FUNCTIONS (The buttons connect to these)
# Students must fill in the logic to call the core functions above.
# The code below may only be changed if they want to change the look of the application
# =====================================================================================

# --- Below this everything is generated by AI ---

def add_contact_handler():
    """Handles the 'Add Contact' button click."""
    name = entry_name.get()
    phone = entry_phone.get()
    email = entry_email.get()
    address = entry_address.get()
    
    # Ignore placeholder text if it hasn't been changed
    if name == entry_name.label_text: name = ""
    if phone == entry_phone.label_text: phone = ""
    if email == entry_email.label_text: email = ""
    if address == entry_address.label_text: address = ""
    
    result_message = add_contact(name, phone, email, address)
    messagebox.showinfo("Result", result_message)
    clear_entries()
    display_all_contacts(result_text)


def display_all_handler():
    """Handles the 'Display All' button click."""
    display_all_contacts(result_text)

def search_contact_handler():
    """Handles the 'Search' button click."""
    name_to_search = entry_name.get()
    
    # Check if we have valid input (not empty and not the placeholder)
    if name_to_search and name_to_search != entry_name.label_text:
        search_result = search_contact(name_to_search)
        
        result_text.delete('1.0', tk.END)
        lines = search_result.splitlines()

        # The result string has at least one line (the status/error message)
        if len(lines) > 1:
            # Line 0: Status message (Light Indigo)
            result_text.insert(tk.END, lines[0] + "\n", 'header') 
            # Line 1: Column Headers (Cyan)
            result_text.insert(tk.END, lines[1] + "\n", 'column_header')
            # Line 2: Separator
            result_text.insert(tk.END, lines[2] + "\n")
            # Remaining: Data
            result_text.insert(tk.END, "\n".join(lines[3:]))
        else:
            # Not found message (only one line)
            result_text.insert(tk.END, search_result)

        
    else:
        messagebox.showwarning("Input Error", "Enter a name to search in the 'Name (Old Name/Search)' field.")

def delete_contact_handler():
    """Handles the 'Delete' button click."""
    name_to_delete = entry_name.get()
    if name_to_delete and name_to_delete != entry_name.label_text:
        result_message = delete_contact(name_to_delete)
        messagebox.showinfo("Result", result_message)
        clear_entries()
        display_all_contacts(result_text)
    else:
        messagebox.showwarning("Input Error", "Enter the name of the contact to delete in the 'Name (Old Name/Search)' field.")

def update_contact_handler():
    """Handles the 'Update' button click."""
    old_name = entry_name.get()
    new_name = entry_new_name.get()  
    new_phone = entry_phone.get()
    new_email = entry_email.get()
    new_address = entry_address.get()
    
    # Ignore placeholder text
    if old_name == entry_name.label_text: old_name = ""
    if new_name == entry_new_name.label_text: new_name = ""
    if new_phone == entry_phone.label_text: new_phone = ""
    if new_email == entry_email.label_text: new_email = ""
    if new_address == entry_address.label_text: new_address = ""


    if old_name:
        result_message = update_contact(old_name, new_name, new_phone, new_email, new_address)
        messagebox.showinfo("Result", result_message)
        clear_entries()
        display_all_contacts(result_text)
    else:
        messagebox.showwarning("Input Error", "Enter the name of the contact to update in the 'Name (Old Name/Search)' field.")


def clear_entries():
    """Helper function to clear all input fields and reset placeholders."""
    # List of all entry widgets
    entries = [entry_name, entry_new_name, entry_phone, entry_email, entry_address]
    
    for entry in entries:
        entry.delete(0, tk.END)
        # Re-insert placeholders and set placeholder color
        entry.insert(0, entry.label_text)
        # Force the placeholder color
        entry.config(fg=THEME["ENTRY_PH"])

# ======================================================================
# TKINTER UI SETUP (Scaffolded: All structure provided)
# ======================================================================

THEME = {
    "BG": "#111827",        # Deep dark gray background
    "CARD_BG": "#1f2937",   # Darker card background (slate-800)
    "INPUT_BG": "#374151",  # Dark input frame background (slate-700)
    "INPUT_BD_COLOR": "#4b5563", # Input frame border (slate-600)
    "PRIMARY": "#818cf8",   # Light Indigo (for contrast/action/status headers)
    "ACCENT_HEADER": "#22d3ee", # Bright Cyan (NEW: For column headings)
    "TEXT": "#f9fafb",      # White/light text (for regular data rows)
    "ENTRY_PH": "#9ca3af",  # Placeholder color (slate-400)
    "ENTRY_BG": "#2d3748",  # Specific background for the Entry widget itself
    "ENTRY_FG": "#f9fafb",  # Entry foreground color (actual input text)
    "TEXT_AREA_BG": "#374151", # Output area BG
}

# --- Visual Configuration ---
MAIN_FONT = ("Inter", 12) 
TITLE_FONT = ("Inter", 32, "bold") 


# Setup main window
app = tk.Tk()
app.title("Contact Manager")
app.geometry("1000x750")
app.configure(bg=THEME["BG"]) # Apply main background color

# --- Styling (Using ttk theme manipulation) ---
# Use 'clam' as a stable base theme that allows better custom color control
style = ttk.Style()
style.theme_use('clam')

# Configure Buttons - Regular Action Buttons
style.configure('TButton', 
                background=THEME["PRIMARY"], 
                foreground=THEME["CARD_BG"], # Button text color (contrast)
                font=("Inter", 12, "bold"), 
                borderwidth=0,
                padding=[12, 12]) 
style.map('TButton', 
          background=[('active', THEME["PRIMARY"])]) # Prevent color change on active state

# Configure Scrollbar Style to match the dark theme
style.configure('Vertical.TScrollbar',
                troughcolor=THEME["TEXT_AREA_BG"], 
                background=THEME["INPUT_BD_COLOR"], 
                bordercolor=THEME["TEXT_AREA_BG"],
                arrowcolor=THEME["TEXT"],
                lightcolor=THEME["INPUT_BD_COLOR"],
                darkcolor=THEME["INPUT_BD_COLOR"])
style.map('Vertical.TScrollbar',
          background=[('active', THEME["PRIMARY"])]) 


# --- Main Card Frame (Center container) ---
main_card = tk.Frame(app, bg=THEME["CARD_BG"], padx=40, pady=40, relief=tk.FLAT, bd=0)
main_card.place(relx=0.5, rely=0.5, anchor=tk.CENTER, relwidth=0.9, relheight=0.9)
main_card.grid_columnconfigure(0, weight=1)
main_card.grid_rowconfigure(3, weight=1) # Results area takes up remaining space


# --- Header Frame (Title Only) ---
header_frame = tk.Frame(main_card, bg=THEME["CARD_BG"])
header_frame.grid(row=0, column=0, sticky='ew', pady=(0, 30))
header_frame.grid_columnconfigure(0, weight=1)

# Title (sticky='ew' combined with grid_columnconfigure(0, weight=1) centers the title)
tk.Label(header_frame, text="Contact Manager", font=TITLE_FONT, fg=THEME["PRIMARY"], bg=THEME["CARD_BG"], anchor='center').grid(row=0, column=0, sticky='ew', pady=(0, 0))


# --- Input Frame (Card-in-Card Look) ---
input_frame = tk.Frame(main_card, bg=THEME["INPUT_BG"], padx=20, pady=20, relief=tk.FLAT, bd=1, highlightbackground=THEME["INPUT_BD_COLOR"], highlightthickness=1)
input_frame.grid(row=1, column=0, pady=10, sticky='ew')
input_frame.grid_columnconfigure(0, weight=1)
input_frame.grid_columnconfigure(1, weight=1)


# Helper function for input fields with icons/placeholders
def create_input_field(parent, label_text, icon_char, row, col, span=1):
    # Field container Frame
    frame = tk.Frame(parent, bg=THEME["INPUT_BG"])
    frame.grid(row=row, column=col, columnspan=span, padx=15, pady=8, sticky='ew')
    frame.grid_columnconfigure(1, weight=1)
    
    # Icon/Label
    tk.Label(frame, text=icon_char, font=("Inter", 14), fg=THEME["ENTRY_PH"], bg=THEME["INPUT_BG"]).grid(row=0, column=0, padx=(0, 8), sticky='w')
    
    # Entry widget
    entry = tk.Entry(frame, 
                     width=30, 
                     font=MAIN_FONT, 
                     bd=1, 
                     relief=tk.FLAT, 
                     highlightthickness=0, 
                     bg=THEME["ENTRY_BG"],       # Set DARK background explicitly
                     fg=THEME["ENTRY_PH"],       # Start with placeholder color
                     insertbackground=THEME["TEXT"]) # Cursor color (white)
    
    entry.grid(row=0, column=1, sticky='ew', ipady=6, ipadx=4)
    entry.insert(0, label_text) 

    # Store label text for placeholder management
    entry.label_text = label_text

    # Placeholder handlers
    def on_focus_in(event):
        if entry.get() == entry.label_text:
            entry.delete(0, tk.END)
        # Always set to dark foreground color when focused (active typing)
        entry.config(fg=THEME["ENTRY_FG"], bg=THEME["INPUT_BG"], highlightcolor=THEME["PRIMARY"], highlightthickness=2)
            
    def on_focus_out(event):
        if not entry.get().strip():
            entry.insert(0, entry.label_text)
            # Revert to placeholder color when empty and out of focus
            entry.config(fg=THEME["ENTRY_PH"], bg=THEME["ENTRY_BG"], highlightthickness=0)
        # If text is present, keep the foreground color
        else:
            entry.config(fg=THEME["ENTRY_FG"], bg=THEME["ENTRY_BG"], highlightthickness=0)
            
    entry.bind('<FocusIn>', on_focus_in)
    entry.bind('<FocusOut>', on_focus_out)
    
    return entry


# Create all entry fields using the new helper
entry_name = create_input_field(input_frame, "Name (Old Name/Search)", "üë§", 0, 0)
entry_new_name = create_input_field(input_frame, "New Name (For Update)", "üè∑Ô∏è", 0, 1) 
entry_phone = create_input_field(input_frame, "Phone", "üìû", 1, 0)
entry_email = create_input_field(input_frame, "Email", "üìß", 1, 1)
entry_address = create_input_field(input_frame, "Address", "üìç", 2, 0, span=2) 


# --- Button Frame (Centered and Styled) ---
button_frame = tk.Frame(main_card, bg=THEME["CARD_BG"], pady=15)
button_frame.grid(row=2, column=0, sticky='ew')

# Button grid (Using ttk.Button for modern styling)
ttk.Button(button_frame, text=" Add", command=add_contact_handler, style='TButton').pack(side=tk.LEFT, padx=7, expand=True, fill='x')
ttk.Button(button_frame, text=" Display All", command=display_all_handler, style='TButton').pack(side=tk.LEFT, padx=7, expand=True, fill='x')
ttk.Button(button_frame, text=" Search", command=search_contact_handler, style='TButton').pack(side=tk.LEFT, padx=7, expand=True, fill='x')
ttk.Button(button_frame, text=" Update", command=update_contact_handler, style='TButton').pack(side=tk.LEFT, padx=7, expand=True, fill='x')
ttk.Button(button_frame, text=" Delete", command=delete_contact_handler, style='TButton').pack(side=tk.LEFT, padx=7, expand=True, fill='x')


# --- Output Area (Styled Text Widget) ---
output_container = tk.Frame(main_card, bg=THEME["TEXT_AREA_BG"], relief=tk.FLAT, bd=1, highlightbackground=THEME["INPUT_BD_COLOR"], highlightthickness=1)
output_container.grid(row=3, column=0, sticky='nsew', pady=(10, 0))
output_container.grid_columnconfigure(0, weight=1)
output_container.grid_rowconfigure(0, weight=1)

# Text Widget for Results
result_text = tk.Text(output_container, 
                      height=1, 
                      width=1, 
                      wrap=tk.WORD, 
                      font=("Consolas", 11), # Monospaced font is crucial for alignment
                      bd=0, 
                      bg=THEME["TEXT_AREA_BG"], 
                      fg=THEME["TEXT"], 
                      insertbackground=THEME["TEXT"],
                      padx=10, 
                      pady=10)
result_text.grid(row=0, column=0, sticky='nsew')

# Scrollbar for the Text Widget
scrollbar = ttk.Scrollbar(output_container, orient=tk.VERTICAL, command=result_text.yview, style='Vertical.TScrollbar')
scrollbar.grid(row=0, column=1, sticky='ns')

# Final link configuration
result_text.config(yscrollcommand=scrollbar.set)

# Add a style tag for status lines (Light Indigo)
result_text.tag_configure('header', font=("Consolas", 11, "bold"), foreground=THEME["PRIMARY"])
# Add a distinct style tag for the column headings (Bright Cyan)
result_text.tag_configure('column_header', font=("Consolas", 11, "bold"), foreground=THEME["ACCENT_HEADER"])

# Initial display 
display_all_contacts(result_text)

# Start the application
if __name__ == "__main__":
    app.mainloop()